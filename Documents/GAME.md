

# Once Upon A Time

## Зміст
<!--ts-->
   * [Про гру](#про-гру)
   * [Архітектура](#архітектура)
       * [Проблеми та шляхи їх вирішення](#проблеми-та-шляхи-їх-вирішення)
       * [Переваги та недоліки підходу](#переваги-та-недоліки-підходу)
   * [Автоматична генерація карти підземелля](#автоматична-генерація-карти-підземелля)
       * [Генерація карти](#генерація-карти)
       * [Створення ворогів, монет та сердечок](#створення-ворогів-монет-та-сердечок)
       * [Проблеми та шляхи їх вирішення](#проблеми-та-шляхи-їх-вирішення)
       * [Переваги та недоліки підходу](#переваги-та-недоліки-підходу)
   * [Головний герой](#головний-герой)
   * [Вороги та штучний інтелект для їх руху](#вороги-та-штучний-інтелект-для-їх-руху)
<!--te-->

## Про гру
Командою було розроблено гру у жанрі Roguelike. Існує три карти: меню гри, місто та підземелля. Гравець має змогу грати за Ельфа, якого, знаходячись у місті, він готує до небезпечного (але прибуткового) походу в підземелля, де він нищитиме ворогів та зароблятиме золото...

На відміну від стереотипу, що ельфи використовують лук, як зброю, наш Ельф б'ється величезним мечем, що дозволяє йому наносисти сильніші удари ворогам.

У будь-який момент, знаходячись у підземеллі, можна натиснути на паузу та призупинити ігровий процес.

## Архітектура
Гра була розроблена за архітектурою AMVCC. Детальніше можна ознайомитися за посиланням https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development.

**Модель**

 1. Містить основні дані програми такі, як здоров'я або тип зброї гравця.
 2. Повідомляє контролер про прогрес операцій.
 3. Зберігає стан кінцевого автомата гри.

**Представлення**
 1. Може отримувати дані з моделі для відображення поточного стану гри. Наприклад, метод player.move() використовує model.speed для наочного відображення руху гравця.
 2. Ніколи не змінює Модель.
 3. Не зберігає важливих даних таких як: швидкість, здоров'я і таке інше.
 4. Ніколи на змінює стан гри.

**Контролер**
 1. Не зберігає дані гри.
 2. Може, інколи, "відкидати" повідомлення від небажаних *Представлень*.
 3. Оновлює та використовує дані з *Моделі*.
 4. Керує перебігом дій на сцені в Unity.

**Додаток**
1. Єдина точка входу до програми та контейнер всіх критичних екземплярів та даних, пов’язаних із додатком.

**Компонент**
1. Невелика, добре написаний скрипт, який можна використовувати повторно.

### Проблеми та шляхи їх вирішення
Однією з важливих проблем при використанні даного патерну була робота з даними. Оскільки *Контролер* повинен завжди завантажити всі можливі комбінації зміни стану героя і передати їх в *Модель*. *Модель*, в свою чергу, повинна завантажити всі дані для візуалізації і передати їх у *Представлення*. Таким чином процес розробки гри ставав складним, адже окрім передачі стану героя, Ельф взаємодіяв з різними об'єктами, наприклад з Орком. Тому було використовано такі засоби як події, які полегшували розробку.

### Переваги та недоліки підходу
**Переваги**
1. ***Єдина концепція системи.*** Безсумнівним плюсом є єдина глобальна архітектура програми. Навіть в складних системах, розробники можуть легко орієнтуватися в програмних блоках. Наприклад, якщо виникла помилка в логіці обробки даних, розробник відразу відкидає перший та другий блоки програми (*Контролер* і *Представлення*) та займається дослідженням третього (*Модель*).
2. ***Спрощено механізм налагодження програми..*** Оскільки весь механізм візуалізації тепер сконцентрований в одному програмному блоці, спростилися механізми опцiонального виведення графічних елементів.

**Недоліки**
1. ***Необхідність використання більшої кількості ресурсів.*** Складність обумовлена тим, що всі три фундаментальних блоки є абсолютно незалежними і взаємодіють між собою виключно шляхом передачі даних. *Контролер* повинен завжди завантажувати (і за необхідності створювати) всі можливі комбінації змінних і передавати їх в *Модель*. *Модель*, в свою чергу, повинна завантажувати всі дані для візуалізації та передавати їх у *Представлення*.
2. ***Ускладнено механізм поділу програми на модулі.*** У концепції MVC наявність трьох блоків (*Модель*, *Представлення*, *Контролер*) прописано жорстко. Відповідно кожен функціональний модуль повинен складатися з трьох блоків, що, в свою чергу, дещо ускладнює архітектуру функціональних модулів програми.
3. ***Ускладнений процес розширення функціоналу.*** Недостатньо просто написати функціональний модуль і підключити його в одному місці програми. Кожен функціональний модуль повинен складатися з трьох частин, і кожна з цих частин повинна бути підключена у відповідному блоці.

## Автоматична генерація карти підземелля
Для створення цікавого рівня потрібна гарна його карта, але малювати їх вручну довго, важко та потрібні навички в дизацні. Проте, якщо карта генерується автоматично, то усі ці проблеми зникають.

Власне кажучи, підземелля не є однією картою, оскільки усе на рівні створюється автоматично, базуючись на налаштуваннях, щоразу, як карта перезавантажується. А саме генеруються наступні об'єтки:
* власне карта,
* вороги, монети, сердечка, двері переходу на наступний рівень та виходу з підземелля.

Зупинюся на кожному пункті детальніше.

### Генерація карти
Базовий принцип генерації рівня складається з двох послідовних процесів: генерація землі, та обнесення усієї землі блоками лісу.

Для генерації землі створюється об'єкт генератора на позиції (0, 0) та він починає "стрибати" в будь-яку з чотирьох сторін (вгору, вниз, вліво та вправо), переміщуючись при цьому на ширину блоку землі, що вказана в параметрах, де також зазначена вірогідність "стрибку" в кожну з 4-х сторін (див. Рисунок 1). Після "приземлення" на новій позиції генератора створюється блок землі, якщо там ще його немає. Процес зупиняється тоді, коли створено кількість блоків, що зазначена в параметрах.

<p align="center">
  <img width="460" src="https://github.com/kushkamisha/OnceUponATime/blob/master/Documents/level-generator.jpg?raw=true" alt="Генерація карти підземелля"><br>
  Рисунок 1. Генератор карти підземелля
</p>

Після того, як земля створена знаходиться мінімальне та максимальне значення згенерованих блоків за кожною віссю (x та y). Від цих значень робиться відступ в стільки блоків, скільки вказано в параметрах та таким чином отримуються координати лісу та його розміри. Виходить прямокутник, в центрі якого - блоки землі, по яким переміщується герой та вороги. Отримавши ці значення генеруються блоки лісу в цьому прямокутнику там, де немає блоків землі.

### Створення ворогів, монет та сердечок
Базуючись на параметрах, на рівні випадковим чином розміщується певна кількість ворогів, до яких підв'язуються скрипти для їх "розумної" поведінки (детальніше див. розділ [Вороги та штучний інтелект для їх руху](#вороги-та-штучний-інтелект-для-їх-руху)). Розміщення відбувається за таким критерієм: вибирається випадковий згенерований блок землі та обирається випадковим чином зміщення від центру цього блоку. На цій позиції і створюється ворог.

Аналогічним способом створюються монети, сердечка та двері переходу на наступний рівень та виходу з підземелля.

### Проблеми та шляхи їх вирішення
Мабуть, найбільш значущою проблемою цього підходу є використання великої кількості ресурсів комп'ютера гравця під час проходження рівня. Це пов'язано з тим, що згенерувавши 50 блоків землі (що є картою середніх розмірів), потрібно додати ще, в середньому, близько 300 блоків лісу (для створення стіни товщиною в 5 блоків). Таким чином виходить близько 350 спрайтів замість одного, у разі використання заздалегідь намальованого рівня, що означає величезну кількість додаткових ресурсів для обрахунку колізій та інших взаємодій.

Оскільки гравець може взаємодіяти лише з тими блоками лісу, що прилягають до блоків землі, а з самою землею гравець взагалі ніяк не взаємодіє, то можна значно оптимізувати гру додавши текстуру замість реальних блоків.

### Переваги та недоліки підходу
**Переваги**
1. Карта генерується автоматично, як і усе на ній, тому не потрібно витрачати багато зусиль на створення одного рівня.
2. Немає жодного обмеження на кількість рівнів та, за правильного алгоритму нарощування складності, грати в таку гру цікаво та захоплююче.

**Недоліки**
1. Генерація карти займає певний час.
2. Потрібно робити опримізацію кількості ігрових об'єктів, оскільки інакше такому рівню потрібно багато ресурсів комп'ютера. 

## Головний герой
Головним героєм цієї гри є Ельф. 
У Ельфа є три класи, а саме: PlayerController, PlayerView та PlayerModel.

В класі PlayerModel зберігається основна характеристика головного персонажа: сила, здоров'я, атака, тощо. Відображення анімацій атаки або руху, зменшення здоров'я - це відбувається у класі PlayerView. Насамкінець в класі PlayerController оброблюються усі дані, які були відправлені з класу PlayerModel.

Для анімації дій Ельфа використовується компонент Animator. Цей компонент використовується для призначення анімації GameObject на сцені. Animator вимагає посилання на контролер Animator, який визначає які саме анімаційні кліпи використовувати та контролює коли і як їх поєднувати та здійснювати переходи між ними. 

AnimatorController - Animator, створений в Unity, що дозволяє організувати та підтримувати набір анімацій для персонажа чи об'єкта. У більшості ситуацій вважається доцільним мати декілька анімацій та "перемикатися" між ними, коли виникають певні умови у гри. Наприклад, у розробленій грі можна переходити з анімації ходи до анімації атаки, коли гравець натискає клавішу пробілу. *Контролер* має посилання на анімаційні кліпи, що використовуються в ньому і керує різними станами анімації та переходами між ними за допомогою кінцевого автомата, який можна розглядати як своєрідну блок-схему.

## Вороги та штучний інтелект для їх руху
Ворогами головного героя є орки, що патрулують підземний світ та хочуть за найменшої нагоди вбити Ельфа. 

У грі Орк складається з трьох класів, а саме: EnemyController, EnemyView та Orc1Model.

В класі Orc1Model зберігається основні характеристики конкретно патрулюючого орка: сила, здоров'я, атака, радіус патрулювання тощо. Відображення анімацій атаки або руху, зменшення здоров'я відбувається у класі EnemyView. У EnemyController, в свою чергу, оброблюються усі дані які були відправлені з класу Orc1Model.

Для того, щоб зробити поведінку Орка більш природньою, було вирішено створити кінцевий автомат для їх поведінки. Це було доцільним, оскільки у ворога можливі всього 3 стани та немає переходів з кожного в кожний (в такому разі краще б підішло дерево рішень). 

Таким чином Орк має такі стани:
1. **Парулювання**. Стан Орка, при якому ворог випадковим чином ходить навколо однієї точки с певним, заздалегідь заданим, радіусом (ці параметри встановлюються кожній істоті при її ініціалізації).
2. **Переслідування**. Стан, при якому Орк намагється наздогнати гравця.
3. **Боротьба**. Стан, за якого Орк наносить удари головному герою (тобто зменшує життєві одиниці Ельфу).

Схема поведінки ворога зображена на Рисунку 2.

<p align="center">
  <img width="460" src="https://github.com/kushkamisha/OnceUponATime/blob/master/Documents/Orc1StateMachine.png?raw=true" alt="Кінцевий автомат для керування Орком"><br>
 Рисунок 2. Кінцевий автомат поведінки патрулюючого Орка
</p>


# Once Upon A Time

## Зміст
<!--ts-->
   * [Про гру](#про-гру)
   * [Автоматична генерація карти підземелля](#автоматична-генерація-карти-підземелля)
   * [Архітектура](#архітектура)
   * [Головний герой](#головний-герой)
   * [Вороги та штучний інтелект для їх руху](#вороги-та-штучний-інтелект-для-їх-противника)
<!--te-->

## Про гру
Командою було розроблено гру у жанрі Roguelike. Гравець має змогу грати за Ельфа, який блукає підземеллям збираючи монетки, які, згодом, він зможе обміняти на зброю, харчі або інші речі у місті. Тобто існує дві карти: місто та підземелля. В місті гравець може одягти свого персонажа до небезпечного походу в підземелля, де він нищитиме ворогів на зароблятиме золото.

## Автоматична генерація карти підземелля
Власне кажучи, підземення не є однією картою, оскільки усе на рівні створюється автоматично, базуючись на налаштуваннях, щоразу, як карта перезавантажується. А саме генеруються наступні об'єтки:
* власне карта,
* вороги
* монети,
* сердечка,
* двері переходу на наступний рівень та виходу з підземелля.

Зупинюся на кожному пункті детальніше.
### Генерація карти
Базовий принцип генерації рівня складається з двох послідовних процесів: генерація землі та обнесення усієї землі блоками лісу.

Для генерації землі створюється об'єкт генератора на позиції (0, 0) та починає "стрибати" в будь-яку з чотирьох сторін (вгору, вниз, вліво та вправо), переміщуючись при цьому на ширину блоку землі, що вказана в параметрах, де також зазначена вірогідність "стрибку" в кожну з 4-х сторін. Після "приземлення" на новій позиції генератора створюється блок землі, якщо там ще немає його. Процес зупиняється тоді, коли створено кількість блоків, що зазначена в параметрах.

## Архітектура
Гра була розроблена за архітектурою AMVCC.

**Модель**
* Містять основні дані програми на кшталт здоров'я або тип зброї гравця. 
* Повідомляють контролер в процесі операції.
* Зберігають стан кінцевого автомата.

**Оглядач**
* Можуть отримувати дані з моделей для відображення поточного стану гри. Наприклад метод player.move() використовує model.speed для наочного відображення руху гравця.
* Ніколи не змінює Модель.
* Не зберігає важливих даних такі як: швидкість, здоров'я і т.д.
* Клас PlayerView ніколи не змінює стан гри

**Контролер**
* Не зберігають основні дані гри.
* Можуть фільтрувати повідомлення від класу View.
* Оновлюють та використовують дані з Моделей.
* Кирують діями на сцені Unity.

**Application**
* Єдина точка входу до програми та контейнер всіх критичних екземплярів та даних, пов’язаних із додатком.

**Component**
* Невеликий, добре вміщений сценарій, який можна використовувати повторно.

## Головний герой
Головним героєм даної гри є ельф. 
У ельфа є три класи, а саме: PlayerController, PlayerView та PlayerModel.

В класі PlayerModel зберігається основна характеристика головного персонажа сила, здоров'є, атака, тощо. Відображення анімацій атаки або руху, зменшення здоров'я відбувається у класі PlayerView. Та в класі PlayerController оброблюються усі дані які були відправлені з класу PlayerModel.

Для анімації дій ельфа використовувався компонент Animator. Компонент Animator використовується для призначення анімації GameObject у сцені. Animator вимагає посилання на контролер Animator, який визначає, які анімаційні кліпи використовувати, та контролює, коли і як їх поєднувати та переходити. 

AnimatorController - Animator створений в Unity і дозволяє організувати та підтримувати набір анімацій для персонажа чи об'єкта. У більшості ситуацій нормально мати кілька анімацій та перемикатися між ними, коли виникають певні умови гри. Наприклад, у даній грі можна переходити з анімації прогулянки на атаку, коли натискаємо пробіл. Контролер має посилання на анімаційні кліпи, що використовуються в ньому, і керує різними станами анімації та переходами між ними за допомогою так званої State-машини, яку можна розглядати як своєрідну блок-схему.

## Вороги та штучний інтелект для їх руху
Супротивниками головного героя - є орки, що патрулують підземний світ, та хочуть при найменшої нагоди вбити ельфа. 
У орка є три класи, а саме: EnemyController, EnemyView та Orc1Model.
В класі Orc1Model зберігається основні характеристики саме патрулюючого орка: сила, здоров'є, атака, радіус патрулювання тощо. Відображення анімацій атаки або руху, зменшення здоров'я відбувається у класі EnemyView. Та в класі EnemyController оброблюються усі дані які були відправлені з класу Orc1Model.

Для того, щоб зробити поведінку ворогів більш природньою, було вирішено створити State Machine для їх поведінки. Оскільки у ворога можливі всього 3 стани та немає переходів з кожного в кожний (за цією ситуацію краще би підішло дерево рішень). Стани:

- Парулювання - стан ворога, при якому орк випадковим чином ходить навколо однієї точки с деяким радіусом (ці параметри встановлюються кожному істоті при ініціалізації)
- Переслідування - стан, при якому орк намагється навздогнати гравця
- Боротьба - стан, при якому ворог наносити пошкодження головному герою (зменшує йому життєві одиниці)

Схема поведінки ворога зображена на малюнку1.

![Orc1 State Machine](https://github.com/kushkamisha/OnceUponATime/blob/master/Documents/Orc1StateMachine.png)
Малюнок1. State Machine оведінки патрулюючого орка:
 
  
